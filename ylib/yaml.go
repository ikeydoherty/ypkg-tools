//
// Copyright Â© 2016 Ikey Doherty
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package ylib

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"reflect"
	"strings"
)

// FieldLen - Pad to locked-right of description: | - longest field
const FieldLen = 11

// MarshalledYpkg is autogenerated by the tooling solely for writing to disk
type MarshalledYpkg struct {
	Name        string
	Version     string
	Homepage    string
	Release     int
	License     []string
	Summary     string
	Component   string
	Description string
	Source      map[string]string
}

func writeYamlLine(buffer *bytes.Buffer, key, value string) {
	if value == "" {
		return
	}
	if strings.Contains(value, "\n") {
		// Handle multiline nicely.
		buffer.WriteString(fmt.Sprintf("%s%*s: |\n", key, FieldLen-len(key), " "))
		for _, line := range strings.Split(value, "\n") {
			buffer.WriteString(fmt.Sprintf("    %s\n", line))
		}
	} else {
		buffer.WriteString(fmt.Sprintf("%s%*s: %s\n", key, FieldLen-len(key), " ", value))
	}
}

func writeYamlSection(buffer *bytes.Buffer, key string) {
	buffer.WriteString(fmt.Sprintf("%s%*s:\n", key, FieldLen-len(key), " "))
}

func writeYamlArray(buffer *bytes.Buffer, key string, value []string) {
	if value == nil {
		return
	}
	// Do it the nice way ..
	if len(value) == 1 {
		writeYamlLine(buffer, key, value[0])
		return
	}
	writeYamlSection(buffer, key)
	for _, item := range value {
		buffer.WriteString(fmt.Sprintf("    - %s\n", item))
	}
}

func writeYamlMap(buffer *bytes.Buffer, key string, values map[string]string) {
	if values == nil || len(values) == 0 {
		return
	}
	writeYamlSection(buffer, key)
	for k, v := range values {
		kjo := fmt.Sprintf("%s : %s", k, v)
		buffer.WriteString(fmt.Sprintf("    - %s\n", kjo))
	}
}

func writeYaml(buffer *bytes.Buffer, thingy interface{}) {
	v := reflect.ValueOf(thingy)
	t := reflect.TypeOf(thingy)
	for i := 0; i < v.NumField(); i++ {
		fs := t.Field(i)
		fsv := v.Field(i)

		key := strings.ToLower(fs.Name)

		switch fsv.Kind() {
		case reflect.String:
			writeYamlLine(buffer, key, fsv.String())
		case reflect.Array:
		case reflect.Slice:
			var ret []string
			for i := 0; i < fsv.Len(); i++ {
				ret = append(ret, fsv.Index(i).String())
			}
			writeYamlArray(buffer, key, ret)
		case reflect.Map:
			// TODO: Handle the special map cases.. i.e. map to map and map to string
			fallthrough
		default:
			// Fallback to String() basically.
			writeYamlLine(buffer, key, fmt.Sprintf("%v", fsv))
		}
	}
}

// WriteYpkg will attempt to write the MarshalledYpkg to a file
func WriteYpkg(path string, pkg *MarshalledYpkg) error {
	var output bytes.Buffer

	writeYaml(&output, *pkg)

	return ioutil.WriteFile(path, output.Bytes(), 00644)
}
